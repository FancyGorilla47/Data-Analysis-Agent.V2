<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>InsightIQ - Data Analysis Assistant</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <style>
        :root {
            --primary-blue: #005a9e; --secondary-blue: #0072bb; --accent-gold: #ffcc00;
            --text-light: #ffffff; --text-dark: #333333; --bg-light: #f4f6f8;
            --bg-medium: #e9eef2; --bg-white: #ffffff; --border-color: #d1d8e0;
            --log-bg: #2d333b; --log-text: #cdd9e5;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Roboto', sans-serif; }
        html, body { height: 100%; overflow: hidden; background-color: var(--bg-light); color: var(--text-dark); }
        body { display: flex; flex-direction: column; line-height: 1.5; }
        header { background-color: var(--primary-blue); padding: 20px; text-align: center; color: var(--text-light); flex-shrink: 0; border-bottom: 4px solid var(--accent-gold); }
        header h1.header-title { font-size: 1.6rem; font-weight: 500; margin: 0; }
        .hero { background: var(--secondary-blue); color: var(--text-light); padding: 15px 20px; text-align: center; flex-shrink: 0; box-shadow: inset 0 -2px 4px rgba(0,0,0,0.1); }
        .hero h2 { font-size: 1.3rem; font-weight: 500; margin-bottom: 3px; }
        .hero p { font-size: 0.95rem; max-width: 700px; margin: auto; font-weight: 300; }
        .chat-section { flex-grow: 1; padding: 20px; display: flex; flex-direction: row; gap: 20px; min-height: 0; overflow: hidden; max-width: 1800px; width: 100%; margin: 0 auto; }
        .chat-container { flex: 3; min-width: 0; border: 1px solid var(--border-color); border-radius: 12px; overflow: hidden; display: flex; flex-direction: column; background-color: var(--bg-white); box-shadow: 0 5px 15px rgba(0, 50, 100, 0.1); }
        #chatbox { flex-grow: 1; padding: 25px; overflow-y: auto; background: var(--bg-white); display: flex; flex-direction: column; gap: 12px; }
        #chatbox::-webkit-scrollbar { width: 8px; }
        #chatbox::-webkit-scrollbar-track { background: var(--bg-medium); border-radius: 4px; }
        #chatbox::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 4px; border: 2px solid var(--bg-medium); }
        #chatbox::-webkit-scrollbar-thumb:hover { background-color: #a8b0b8; }
        .message { padding: 12px 18px; border-radius: 20px; max-width: 80%; word-wrap: break-word; line-height: 1.45; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); }
        .message.user { background: linear-gradient(to bottom right, var(--secondary-blue), var(--primary-blue)); color: var(--text-light); align-self: flex-end; border-bottom-right-radius: 8px; margin-left: auto; }
        .message.bot {
            position: relative; /* FIX #1: The bubble is now the parent for positioning */
            background-color: var(--bg-medium); color: var(--text-dark); align-self: flex-start;
            border-bottom-left-radius: 8px; margin-right: auto; border: 1px solid #dce1e6;
            overflow-x: auto;
        }
        .message.bot table { border-collapse: collapse; width: 100%; margin: 12px 0; font-size: 0.9em; box-shadow: 0 1px 3px rgba(0,0,0,0.05); border-radius: 4px; overflow: hidden; }
        .message.bot th, .message.bot td { border: 1px solid #e1e6ec; padding: 10px 12px; text-align: left; }
        .message.bot th { background-color: #e9eef2; font-weight: 500; }
        .message.bot tr:nth-child(even) td { background-color: #f8fafd; }
        #status { text-align: center; padding: 6px 5px; color: #6c757d; font-size: 0.85em; min-height: 1.5em; background-color: var(--bg-medium); border-top: 1px solid var(--border-color); flex-shrink: 0; line-height: 1.2; display: flex; align-items: center; justify-content: center; gap: 8px; }
        #inputArea { display: flex; border-top: 1px solid var(--border-color); flex-shrink: 0; background-color: var(--bg-white); }
        #userInput { flex: 1; padding: 16px; border: none; font-size: 1rem; outline: none; background-color: transparent; }
        #userInput::placeholder { color: #99a4b0; font-weight: 300; }
        #sendButton { background-color: var(--secondary-blue); color: var(--text-light); border: none; padding: 0 25px; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s ease; }
        #sendButton:hover { background-color: var(--primary-blue); }
        #sendButton:disabled { background-color: #b0c4de; cursor: not-allowed; }
        #newChatButton { background-color: transparent; color: var(--primary-blue); border: none; border-right: 1px solid var(--border-color); padding: 0 20px; cursor: pointer; font-size: 1.1rem; transition: color 0.2s ease; }
        #newChatButton:hover { color: var(--secondary-blue); }
        #log-container { flex: 2; min-width: 400px; border-radius: 12px; overflow: hidden; display: flex; flex-direction: column; background-color: var(--log-bg); box-shadow: 0 5px 15px rgba(0, 50, 100, 0.1); }
        .log-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 15px; background-color: #3e444b; color: var(--text-light); font-size: 0.9rem; flex-shrink: 0; }
        .log-header h3 { font-weight: 500; margin: 0; }
        #hide-logs-btn { background: none; border: 1px solid var(--border-color); color: var(--text-light); padding: 3px 8px; cursor: pointer; border-radius: 5px; font-size: 0.8em; }
        #log-box { flex-grow: 1; min-height: 0; overflow-y: auto; padding: 15px; color: var(--log-text); font-family: 'Courier New', Courier, monospace; font-size: 0.85em; line-height: 1.4; white-space: pre-wrap; word-break: break-all; }
        .log-message { padding-bottom: 5px; border-bottom: 1px solid #444c56; margin-bottom: 5px; }
        .log-message:last-child { border-bottom: none; margin-bottom: 0; }
        #log-box::-webkit-scrollbar { width: 8px; }
        #log-box::-webkit-scrollbar-track { background: #22272e; }
        #log-box::-webkit-scrollbar-thumb { background-color: #58a6ff; border-radius: 4px; }
        .bot-message-container { align-self: flex-start; width: fit-content; max-width: 80%; }
        .export-bubble-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--primary-blue);
            border: none;
            color: var(--text-light);
            display: grid;
            place-items: center;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: opacity 0.2s, transform 0.2s;
            opacity: 0;
            transform-origin: center;
        }
        .bot-message-container:hover .export-bubble-btn { opacity: 1; transform: scale(1); }
        .export-bubble-btn:hover { background-color: var(--secondary-blue); }
        .export-bubble-btn:active { transform: scale(0.92); }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .spinning { animation: spin 1.2s linear infinite; }
        .hidden { display: none !important; }
        #show-logs-btn {
            position: fixed; bottom: 20px; right: 20px; z-index: 1000;
            background-color: var(--primary-blue); color: var(--text-light);
            border: 1px solid var(--text-light); border-radius: 8px; padding: 10px 16px;
            font-size: 1rem; font-weight: 500; cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
        }
        #show-logs-btn:hover { background-color: var(--secondary-blue); transform: translateY(-2px); }
    </style>
</head>
<body>
    <header>
        <h1 class="header-title">InsightIQ Data Assistant</h1>
    </header>
    <section class="hero">
        <h2>Welcome to Your Smart Data Assistant</h2>
        <p>Ask complex questions about your business data in plain language.</p>
    </section>
    <section class="chat-section">
        <div class="chat-container">
            <div id="chatbox">
                <div class="message bot">Hello! How can I assist with your data analysis today?</div>
            </div>
            <div id="status">Ready.</div>
            <form id="inputArea">
                <button id="newChatButton" title="New Chat" type="button"><i class="fas fa-plus"></i></button>
                <input type="text" id="userInput" placeholder="Ask a question..." autocomplete="off">
                <button id="sendButton" title="Send Message" type="submit"><i class="fas fa-paper-plane"></i></button>
            </form>
        </div>
        <div id="log-container">
            <div class="log-header">
                <h3>Execution Logs</h3>
                <button id="hide-logs-btn">Hide</button>
            </div>
            <div id="log-box"></div>
        </div>
    </section>

    <button id="show-logs-btn" class="hidden">Show Logs</button>

    <script>
    // --- 1. Element References ---
    const chatbox = document.getElementById('chatbox');
    const userInput = document.getElementById('userInput');
    const sendButton = document.getElementById('sendButton');
    const newChatButton = document.getElementById('newChatButton');
    const statusDiv = document.getElementById('status');
    const logBox = document.getElementById('log-box');
    const logContainer = document.getElementById('log-container');
    const inputForm = document.getElementById('inputArea');
    let currentSessionId = null;
    const hideLogsBtn = document.getElementById('hide-logs-btn');
    const showLogsBtn = document.getElementById('show-logs-btn');
    
    // --- 2. Core UI Functions ---
    function addMessage(content, sender) { /* (Unchanged) */ }
    function addLogMessage(content) { /* (Unchanged) */ }
    const scrollTimeouts = {}; function debounceScroll(el) { /* (Unchanged) */ }

    // --- 3. Event Listeners ---
    newChatButton.addEventListener('click', () => {
        currentSessionId = null;
        chatbox.innerHTML = '<div class="message bot">Hello! How can I assist with your data analysis today?</div>';
        logBox.innerHTML = '';
        statusDiv.textContent = 'Ready.';
        sendButton.disabled = false;
        userInput.disabled = false;
        userInput.focus();
    });

    hideLogsBtn.addEventListener('click', () => {
        logContainer.classList.add('hidden');
        showLogsBtn.classList.remove('hidden');
    });

    showLogsBtn.addEventListener('click', () => {
        logContainer.classList.remove('hidden');
        showLogsBtn.classList.add('hidden');
    });

    inputForm.addEventListener("submit", (e) => {
        e.preventDefault();
        handleSend();
    });

    // --- 4. Main Streaming and Logic Handler ---
    async function handleSend() {
        const query = userInput.value.trim();
        if (!query || sendButton.disabled) return;
        let answerForThisMessage = "";
        addMessage(query, 'user');
        userInput.value = '';
        sendButton.disabled = true;
        userInput.disabled = true;
        statusDiv.innerHTML = `<i class="fas fa-spinner spinning"></i> Thinking...`;
        const botContainer = document.createElement("div");
        botContainer.className = "bot-message-container";
        const botDiv = document.createElement("div");
        botDiv.classList.add("message", "bot");
        botDiv.textContent = "Processing your request...";
        // Note: The botDiv is appended to the container, and the container to the chatbox
        // This is done so the :hover selector on the container can show the button,
        // which will now be appended directly to botDiv.
        botContainer.appendChild(botDiv);
        chatbox.appendChild(botContainer);
        debounceScroll(chatbox);
        try {
            const response = await fetch('/ask_sql', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query, session_id: currentSessionId }),
            });
            if (!response.ok) { throw new Error((await response.text()) || `Network error: ${response.status}`); }
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                let boundary = buffer.indexOf('\n\n');
                while (boundary !== -1) {
                    const packet = buffer.substring(0, boundary);
                    buffer = buffer.substring(boundary + 2);
                    let eventName = 'data', eventData = '';
                    for (const line of packet.split('\n')) {
                        if (line.startsWith('event:')) eventName = line.slice(6).trim();
                        else if (line.startsWith('data:')) eventData = line.slice(5).trim();
                    }
                    if (eventData) {
                        try {
                            const json = JSON.parse(eventData);
                            switch(eventName) {
                                case 'log': addLogMessage(json.message); break;
                                case 'status': statusDiv.innerHTML = `<i class="fas fa-spinner spinning"></i> ${DOMPurify.sanitize(json.message)}`; break;
                                case 'data':
                                    answerForThisMessage = json.answer || "";
                                    botDiv.innerHTML = DOMPurify.sanitize(marked.parse(answerForThisMessage));
                                    break;
                                case 'error':
                                    botDiv.innerHTML = `<span style="color: #d9534f;">${json.message}</span>`;
                                    statusDiv.textContent = 'Error occurred';
                                    break;
                                case 'end':
                                    currentSessionId = json.session_id;
                                    statusDiv.textContent = 'Ready.';
                                    if (answerForThisMessage?.trim()) {
                                        const exportButton = document.createElement('button');
                                        exportButton.className = 'export-bubble-btn';
                                        exportButton.title = "Export to PDF";
                                        exportButton.innerHTML = '<i class="fas fa-file-pdf"></i>';
                                        exportButton.addEventListener('click', () => { generatePDF(query, answerForThisMessage); });
                                        // FIX #1: Append to the visible bubble (botDiv)
                                        botDiv.appendChild(exportButton);
                                    }
                                    break;
                            }
                        } catch (e) { console.error("SSE parse failed:", e, eventData); }
                    }
                    boundary = buffer.indexOf('\n\n');
                }
                debounceScroll(chatbox);
                debounceScroll(logBox);
            }
        } catch (err) {
             botDiv.innerHTML = `<span style="color:#d9534f;font-weight:600;">An error occurred:</span><br>${err.message}`;
             statusDiv.textContent = 'Error occurred';
        } finally {
            sendButton.disabled = false;
            userInput.disabled = false;
            userInput.focus();
            if (statusDiv.innerHTML.includes('spinning')) { statusDiv.textContent = 'Ready.'; }
            debounceScroll(chatbox);
            debounceScroll(logBox);
        }
    }

    // --- 5. PDF Generation Functions ---
function generatePDF(query, answer) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape' });
    let finalY = 20; // This will track the vertical position on the page

    // --- Renders initial header and user query ---
    doc.setFontSize(18);
    doc.text("Data Analysis Report", 15, finalY);
    finalY += 12;
    doc.setFontSize(12);
    doc.text("Your Question:", 15, finalY);
    finalY += 8;
    doc.setFont("helvetica", "normal");
    const queryLines = doc.splitTextToSize(query, 260);
    doc.text(queryLines, 15, finalY);
    finalY = doc.autoTable.previous.finalY + 10;

    // --- NEW LOGIC: Splits the entire report into text and table chunks ---
    const chunks = [];
    let currentChunk = { type: 'text', lines: [] };
    const lines = answer.split('\n');

    for (const line of lines) {
        const isTableLine = line.trim().startsWith('|');
        // If we find a table line...
        if (isTableLine) {
            // ...and we were in a text chunk, save the text chunk and start a new table chunk.
            if (currentChunk.type === 'text') {
                if (currentChunk.lines.join('').trim()) {
                    chunks.push({ type: 'text', content: currentChunk.lines.join('\n') });
                }
                currentChunk = { type: 'table', lines: [line] };
            } else {
                currentChunk.lines.push(line);
            }
        // If we find a text line...
        } else {
            // ...and we were in a table chunk, save the table chunk and start a new text chunk.
            if (currentChunk.type === 'table') {
                chunks.push({ type: 'table', content: currentChunk.lines.join('\n') });
                currentChunk = { type: 'text', lines: [line] };
            } else {
                currentChunk.lines.push(line);
            }
        }
    }
    // Add the final chunk to the array
    if (currentChunk.lines.join('').trim()) {
        chunks.push({ type: currentChunk.type, content: currentChunk.lines.join('\n') });
    }

    // --- Loop through the chunks and render each one correctly ---
    for (const chunk of chunks) {
        // Check if the next chunk will fit on the page, otherwise add a new page
        // (This is a simple check; more complex checks could calculate exact height)
        if (finalY > 250) { 
            doc.addPage();
            finalY = 20;
        }

        if (chunk.type === 'text') {
            // Render plain text using autoTable for better wrapping
            doc.autoTable({
                startY: finalY,
                body: [[chunk.content]],
                theme: 'plain',
                styles: { fontSize: 10, cellPadding: 0 },
            });
            finalY = doc.autoTable.previous.finalY; // Update Y position
        } else if (chunk.type === 'table') {
            // Render a markdown table with full styling
            const { head, body } = parseMarkdownTable(chunk.content);
            doc.autoTable({
                startY: finalY + 5, // Add a little space before tables
                head: head,
                body: body,
                theme: 'grid',
                headStyles: { fillColor: [0, 90, 158] },
                styles: {
                    fontSize: 8,
                    cellPadding: 2,
                    overflow: 'linebreak',
                    minCellWidth: 20
                }
            });
            finalY = doc.autoTable.previous.finalY; // Update Y position
        }
    }

    // --- Generate a dynamic filename and save ---
    const now = new Date();
    const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
    const safeQuery = query.replace(/[\\/*?:"<>|]/g, '').substring(0, 40).trim();
    const filename = `${safeQuery}_${timestamp}.pdf`;
    
    doc.save(filename);
}

    function extractReportParts(fullText) { /* (Unchanged) */ }
    function parseMarkdownTable(markdown) { /* (Unchanged) */ }

    // --- 6. Initial Setup ---
    userInput.focus();

    /*****UNCHANGED FUNCTION DEFINITIONS (kept for completeness) *****/
    function addMessage(content, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', sender);
        messageDiv.innerHTML = DOMPurify.sanitize(marked.parse(content));
        chatbox.appendChild(messageDiv);
        debounceScroll(chatbox);
        return messageDiv;
    }
    function addLogMessage(content) {
        const logMessageDiv = document.createElement('div');
        logMessageDiv.classList.add('log-message');
        logMessageDiv.textContent = content;
        logBox.appendChild(logMessageDiv);
        debounceScroll(logBox);
    }
    function debounceScroll(el) {
        const id = el.id || 'default';
        clearTimeout(scrollTimeouts[id]);
        scrollTimeouts[id] = setTimeout(() => { el.scrollTop = el.scrollHeight; }, 50);
    }
    function extractReportParts(fullText) {
        const lines = fullText.split('\n');
        let preambleLines = [], tableLines = [], postambleLines = [], state = 'preamble';
        for (const line of lines) {
            const isTableLine = line.trim().startsWith('|');
            if (state === 'preamble') { if (isTableLine) { state = 'table'; tableLines.push(line); } else { preambleLines.push(line); } }
            else if (state === 'table') { if (isTableLine) { tableLines.push(line); } else { state = 'postamble'; postambleLines.push(line); } }
            else if (state === 'postamble') { postambleLines.push(line); }
        }
        const preambleText = preambleLines.join('\n').replace(/##\s*Supporting Data/i, '').trim();
        return { preambleText: preambleText, tableMarkdown: tableLines.join('\n'), postambleText: postambleLines.join('\n').trim() };
    }
    function parseMarkdownTable(markdown) {
        const lines = markdown.trim().split('\n');
        const head = [], body = [];
        const processRow = (line) => line.split('|').slice(1, -1).map(cell => cell.trim());
        if (lines.length > 0) head.push(processRow(lines[0]));
        for (let i = 1; i < lines.length; i++) {
            if (lines[i].includes('---')) continue;
            body.push(processRow(lines[i]));
        }
        return { head, body };
    }
    </script>
</body>
</html>